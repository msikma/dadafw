// Dada Web Framework <https://github.com/msikma/dadafw>
// Copyright (C) 2013-2015, Michiel Sikma <michiel@sikma.org> and contributors
// MIT licensed

/**
 * Grid System / Functions
 *
 * The functions that construct the grid.
 */

// Sets the full grid width.
@mixin grid-layout($stage, $viewport-width, $grid-width, $col-gutter)
{
  $col-half-gutter: $col-gutter / 2;

  @media screen and (min-width: $viewport-width) {
    .grid {
      width: $grid-width;
      padding-left: $col-half-gutter;
      padding-right: $col-half-gutter;
    }
    .row {
      margin-left: -$col-half-gutter;
      margin-right: -$col-half-gutter;
    }
  }
}

// Mixin that creates a grid for a single responsive size.
@mixin grid-cols($stage, $viewport-width, $col-gutter, $col-amount,
  $semantic-cols)
{
  $col-half-gutter: $col-gutter / 2;

  @media screen and (min-width: $viewport-width) {
    // Basic column size:
    .col {
      @include flex-basis(100%);
      padding-left: $col-half-gutter;
      padding-right: $col-half-gutter;
      width: 100%;
    }
    // An element can be hidden when a specific responsive size is active.
    // Hide the ones that pertain to this size.
    .xs-hidden {
      // The xs-hidden elements are always shown in a grid.
      display: block;
    }
    // (FIXME, only works for default grid)
    @if ($stage == l or $stage == m) {
      .col.s-hidden {
        display: none;
      }
    }
    @if ($stage == l) {
      .col.m-hidden {
        display: none;
      }
    }
    .col.#{$stage}-hidden {
      display: none;
    }

    // Calculate the sizes of the grid columns.
    $i: $col-amount;
    @while $i > 0 {
      $size: percentage($i / $col-amount);
      .w-#{$i}, .col.w-#{$stage}-#{$i} {
        @include flex-basis($size);
      }
      .col.offset-#{$i} {
        margin-left: $size;
      }
      $i: $i - 1;
    }

    // Aside from the regular block grid, we also provide text column classes.
    // These have the same sizes as regular columns, but they work through
    // the use of column-span. They can be used to neatly make text from
    // a single container span across multiple columns.
    $i: $col-amount;
    @while $i > 0 {
      .colspan-#{$i} {
        @include column-count($i);
      }
      $i: $i - 1;
    }
    // Set the gap between the columns.
    .col {
      @include column-gap($col-gutter);
    }

    // Set up semantic columns in case they exist.
    @if nth($semantic-cols, 1) != null {
      $i: length($semantic-cols);
      @while $i > 0 {
        $col: nth(map-keys($semantic-cols), $i);
        $col-data: map-get($semantic-cols, $col);

        // Set the semantic column's width, and optionally the
        // column-count value.
        .#{$col} {
          @if map-has-key($col-data, 'w') {
            width: percentage(map-get($col-data, 'w') / $col-amount);
          }
          @if map-has-key($col-data, 'colspan') {
            @include column-count(map-get($col-data, 'colspan'));
          }
        }

        $i: $i - 1;
      }
    }
  }
}

// Adds some scaffolding styles for viewports wider than mobile.
@mixin grid-desktop($viewport-width) {
  @media screen and (min-width: $viewport-width) {
    // Remove the extra side padding for mobile.
    body {
      padding-left: 0;
      padding-right: 0;
    }

    // Prevent wrapping of column rows.
    .row {
      @include flex-flow(row nowrap);
    }
  }
}

@mixin construct-grid($grid) {
  // We've got specific styles that apply only to mobile, and styles
  // that apply only to desktop.
  //
  // In order to apply these correctly, we need to know where the mobile
  // size stops and the desktop size begins. We'll loop through the grid map
  // until we find the largest (last) mobile size.
  $i: 0;
  $post-mobile: false;
  $mobile-desktop-treshold: 0;
  @while $i < length($grid) {
    $stage: nth(map-keys($grid), $i + 1);
    $stage-data: map-get($grid, $stage);
    $viewport-width: map-get($stage-data, 'viewport-width');
    $is-mobile: map-get($stage-data, 'is-mobile');
    @if $is-mobile == true {
      $mobile-desktop-treshold: $viewport-width;
    }
    $i: $i + 1;
  }

  @if $grid-debug-include == true {
    // Include the basic grid debugging classes common to all sizes.
    @include grid-debug();

    // Now we'll implement grid debugging classes that are specific to either
    // mobile or desktop sizes.
    @include grid-debug-mobile($mobile-desktop-treshold - 1);
    @include grid-debug-desktop($mobile-desktop-treshold);
  }

  // Implement desktop scaffolding.
  @include grid-desktop($mobile-desktop-treshold);

  // Calculate the grid layout for each responsive stage.
  $i: 0;
  $prev-gutter: 0;
  @while $i < length($grid) {
    $stage: nth(map-keys($grid), $i + 1);
    $stage-data: map-get($grid, $stage);
    
    // Retrieve the stage's info and pass it along to the layout function.
    $viewport-width: map-get($stage-data, 'viewport-width');
    $grid-width: map-get($stage-data, 'grid-width');
    $col-amount: map-get($stage-data, 'col-amount');
    $col-gutter: map-get($stage-data, 'col-gutter');
    $semantic-cols: map-get($stage-data, 'semantic-cols');
    
    // Set up the basic grid settings and the size at which it activates.
    @include grid-layout($stage, $viewport-width, $grid-width, $col-gutter);
    
    // Calculate the sizes and margins for the grid's columns.
    @include grid-cols($stage, $viewport-width, $col-gutter, $col-amount, $semantic-cols);

    // Add stage-specific grid debugging rules, if needed.
    @if $grid-debug-include == true and $col-gutter != $prev-gutter {
      @include grid-debug-stage($viewport-width, $col-gutter);
      $prev-gutter: $col-gutter;
    }

    $i: $i + 1;
  }
}
